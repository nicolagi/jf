package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/rand"
	"reflect"
	"sort"
	"strings"
	"testing"
	"testing/quick"

	"github.com/google/go-cmp/cmp"
)

type flattenerTest struct {
	input  string
	output []pair
}

func (tt *flattenerTest) run(t *testing.T, f *flattener) {
	t.Helper()
	output := f.collect()
	if got, want := len(output), len(tt.output); got != want {
		t.Errorf("got %d, want %d pairs", got, want)
	}
	for i, expected := range tt.output {
		if i >= len(output) {
			break
		}
		actual := output[i]
		if actual.path != expected.path {
			t.Errorf("got %s, want %s for path", actual.path, expected.path)
		}
		if actual.value != expected.value {
			t.Errorf("got %s, want %s for value", actual.value, expected.value)
		}
		if expected.err != nil {
			if actual.err == nil {
				t.Errorf("got nil, want %q", expected.err.Error())
			} else if got, want := actual.err.Error(), expected.err.Error(); got != want {
				t.Errorf("got %q, want %q", got, want)
			}
		} else if actual.err != nil {
			t.Errorf("got %v, want nil", actual.err)
		}
	}
}

// The main testing is via conformance checking in this file. Here
// we'll only add a few basic tests and more tests for specific
// regressions as they are encountered.
func TestFlattenerRegressions(t *testing.T) {
	t.Run("single value", func(t *testing.T) {
		tests := []flattenerTest{
			{
				input: "{}",
				output: []pair{
					{path: ".", value: "{}"},
				},
			},
			{
				input: "[]",
				output: []pair{
					{path: ".", value: "[]"},
				},
			},
			{
				input: "unquoted",
				output: []pair{
					{path: ".", value: "unquoted"},
				},
			},
			{
				input: `"quoted"`,
				output: []pair{
					{path: ".", value: `"quoted"`},
				},
			},
			{
				input: `{ "user": "bob", "friends": [ "alice" ] }`,
				output: []pair{
					{path: ".", value: "{}"},
					{path: `."user"`, value: `"bob"`},
					{path: `."friends"`, value: "[]"},
					{path: `."friends"[0]`, value: `"alice"`},
				},
			},
			{
				input: `1 2`,
				output: []pair{
					{path: ".", value: "1"},
					{err: errors.New("expected to flatten one value and get EOF, got: 2")},
				},
			},
		}
		for _, tt := range tests {
			t.Run("", func(t *testing.T) {
				f := newFlattener(strings.NewReader(tt.input))
				tt.run(t, f)
			})
		}
	})
	t.Run("many values", func(t *testing.T) {
		tests := []flattenerTest{
			{
				input: `1 [ 2 ]`,
				output: []pair{
					{path: ".", value: "1"},
					{path: ".", value: "[]"},
					{path: ".[0]", value: "2"},
				},
			},
			{
				input: `"string" 42 true`,
				output: []pair{
					{path: ".", value: `"string"`},
					{path: ".", value: "42"},
					{path: ".", value: "true"},
				},
			},
			{
				input: `{ "name": "richard", "age": 58 } { "name": "carl", "age": 45 }`,
				output: []pair{
					{path: ".", value: "{}"},
					{path: `."name"`, value: `"richard"`},
					{path: `."age"`, value: "58"},
					{path: ".", value: "{}"},
					{path: `."name"`, value: `"carl"`},
					{path: `."age"`, value: "45"},
				},
			},
		}
		for _, tt := range tests {
			t.Run("", func(t *testing.T) {
				tt.run(t, newFlattener(strings.NewReader(tt.input), acceptMany))
			})
		}
	})
}

// Here is another implementation of flatten, that uses the JSON
// unmarshaler in the standard library. Used to compare against the
// flattener in this package to increase confidence in correctness.
// It's faster too, of course. It requires the whole input though, so
// would not work well in a pipeline.
func stdlibFlatten(input []byte) (pairs []pair) {
	join := func(path, elem string) string {
		if path == "." {
			return path + elem
		}
		return path + "." + elem
	}
	var flattenRecursively func(obj interface{}, path string)
	flattenRecursively = func(obj interface{}, path string) {
		switch v := obj.(type) {
		case nil:
			pairs = append(pairs, pair{path: path, value: "null"})
		case bool:
			pairs = append(pairs, pair{path: path, value: fmt.Sprintf("%t", v)})
		case float64:
			pairs = append(pairs, pair{path: path, value: fmt.Sprintf("%f", v)})
		case string:
			pairs = append(pairs, pair{path: path, value: fmt.Sprintf("%q", v)})
		case map[string]interface{}:
			pairs = append(pairs, pair{path: path, value: `{}`})
			for key, obj := range v {
				flattenRecursively(obj, join(path, fmt.Sprintf("%q", key)))
			}
		case []interface{}:
			pairs = append(pairs, pair{path: path, value: `[]`})
			for i, obj := range v {
				flattenRecursively(obj, path+fmt.Sprintf("[%d]", i))
			}
		default:
			panic(fmt.Sprintf("unhandled input: %v", obj))
		}
	}
	var obj interface{}
	if err := json.Unmarshal(input, &obj); err != nil {
		pairs = append(pairs, pair{err: err})
		return
	}
	flattenRecursively(obj, ".")
	return
}

// jsonValue is a JSON value serialized to a string, randomly
// generated by the testing/quick framework.
type jsonValue string

// Generate implements testing/quick.Generator.
func (jsonValue) Generate(rand *rand.Rand, size int) reflect.Value {
	whitespace := func() string {
		// Half the times this is called, return no whitespace.
		if rand.Intn(2) == 0 {
			return ""
		}
		// Half the times, between 1 and 4 bytes of whitespace.
		ws := make([]byte, 1+rand.Intn(3))
		for i := 0; i < len(ws); i++ {
			switch rand.Intn(3) {
			case 0:
				ws[i] = ' '
			case 1:
				ws[i] = '\t'
			default:
				if i+1 < len(ws) {
					ws[i] = '\r'
					ws[i+1] = '\n'
					i++
				} else {
					ws[i] = '\n'
				}
			}
		}
		return string(ws)
	}
	var genRecursively func(int) string
	genRecursively = func(typ int) string {
		switch typ {
		case 0:
			return whitespace() + "null" + whitespace()
		case 1:
			return whitespace() + "true" + whitespace()
		case 2:
			return whitespace() + "false" + whitespace()
		case 3:
			return whitespace() + fmt.Sprintf("%f", rand.Float64()) + whitespace()
		case 4:
			// A quoted string consisting of at most 8 bytes, and only characters
			// in the class [a-z].
			size := rand.Intn(8)
			qs := make([]byte, size)
			for i := 0; i < size; i++ {
				qs[i] = 'a' + byte(rand.Intn('z'-'a'+1))
			}
			return whitespace() + fmt.Sprintf("%q", qs) + whitespace()
		case 5:
			arr := bytes.NewBufferString(whitespace() + "[")
			// At most 4 values in the array, of random types.
			for sz := rand.Intn(4); sz > 0; sz-- {
				arr.WriteString(genRecursively(rand.Intn(7)))
				if sz > 1 {
					arr.WriteString(",")
				}
			}
			arr.WriteString("]")
			arr.WriteString(whitespace())
			return arr.String()
		default: /*6*/
			keys := make(map[string]bool)
			obj := bytes.NewBufferString("{")
			// At most 4 key-value pairs.
			// Keys are randomly-generated quoted strings.
			// Values are recursively generated, of random type.
			for sz := rand.Intn(4); sz > 0; sz-- {
				key := genRecursively(4)
				for keys[strings.TrimSpace(key)] {
					key = genRecursively(4)
				}
				keys[strings.TrimSpace(key)] = true
				obj.WriteString(key)
				obj.WriteString(":")
				obj.WriteString(genRecursively(rand.Intn(7)))
				if sz > 1 {
					obj.WriteString(",")
				}
			}
			obj.WriteString("}")
			return obj.String()
		}
	}
	return reflect.ValueOf(jsonValue(genRecursively(rand.Intn(7))))
}

func TestFlattenerConformance(t *testing.T) {
	f := func(input jsonValue) bool {
		flattener := newFlattener(strings.NewReader(string(input)))
		var pairs []string
		for _, p := range flattener.collect() {
			if p.err == io.EOF {
				break
			}
			if p.err != nil {
				t.Fatal(p.err)
				return false
			}
			pairs = append(pairs, fmt.Sprintf("%s\t%s", p.path, p.value))
		}
		sort.Strings(pairs)
		var referencePairs []string
		for _, pair := range stdlibFlatten([]byte(input)) {
			path, value, err := pair.path, pair.value, pair.err
			if err != nil {
				t.Fatal(err)
				return false
			}
			referencePairs = append(referencePairs, fmt.Sprintf("%s\t%s", path, value))
		}
		sort.Strings(referencePairs)
		if diff := cmp.Diff(referencePairs, pairs); diff != "" {
			t.Log(diff)
			return false
		}
		return true
	}
	if err := quick.Check(f, nil); err != nil {
		t.Error(err)
	}
}

const sampleValue = `{
	"name": "Death Star",
	"model": "DS-1 Orbital Battle Station",
	"manufacturer": "Imperial Department of Military Research, Sienar Fleet Systems",
	"cost_in_credits": "1000000000000",
	"length": "120000",
	"max_atmosphering_speed": "n/a",
	"crew": "342,953",
	"passengers": "843,342",
	"cargo_capacity": "1000000000000",
	"consumables": "3 years",
	"hyperdrive_rating": "4.0",
	"MGLT": "10",
	"starship_class": "Deep Space Mobile Battlestation",
	"pilots": [],
	"films": [
		"http://swapi.dev/api/films/1/"
	],
	"created": "2014-12-10T16:36:50.509000Z",
	"edited": "2014-12-20T21:26:24.783000Z",
	"url": "http://swapi.dev/api/starships/9/"
}`

func BenchmarkFlattener(b *testing.B) {
	for i := 0; i < b.N; i++ {
		f := newFlattener(strings.NewReader(sampleValue))
		f.run(func(_ string, _ string, err error) {
			if err != nil {
				b.Fatal(err)
			}
		})
	}
}

func BenchmarkReferenceFlattener(b *testing.B) {
	for i := 0; i < b.N; i++ {
		stdlibFlatten([]byte(sampleValue))
	}
}
